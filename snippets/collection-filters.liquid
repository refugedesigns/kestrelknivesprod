<!-- Collection Filters -->
<div
  class='hidden md:block w-full md:w-1/4 lg:w-1/5 mb-8 md:mb-0'
  x-data='collectionFilters()'
>
  <div class='bg-white border border-gray-200 rounded-lg p-6'>
    <h3 class='text-lg font-bold text-gray-900 mb-6'>Filters</h3>

    <!-- Product Type Filter -->
    <div class='mb-6'>
      <button
        @click='toggleFilter("productType")'
        class='flex items-center justify-between w-full text-left font-semibold text-gray-900 mb-3'
      >
        <span>Product Type</span>
        <svg
          class='w-4 h-4 transition-transform duration-200'
          :class="filtersOpen.productType ? 'rotate-180' : ''"
          fill='none'
          stroke='currentColor'
          viewBox='0 0 24 24'
        >
          <path stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'/>
        </svg>
      </button>

      <div x-show='filtersOpen.productType' class='space-y-2'>
        <template x-for='t in productTypes' :key='t.value'>
          <div>
            <label class='flex items-center space-x-2 cursor-pointer'>
              <input
                type='radio'
                name='productType'
                :value='t.value'
                x-model='selectedFilters.productTypeSelected'
                @change='applyFilters(true)'
                class='border-gray-300 text-black focus:ring-gray-900'
              >
              <span
                class='text-sm text-gray-700'
                x-text='titleCase(t.value)'
              ></span>
            </label>

            <!-- Inline apparel tag drill-down (only under Apparel) -->
            <template
              x-if="t.value && t.value.toLowerCase() === 'apparel' && selectedFilters.productTypeSelected && selectedFilters.productTypeSelected.toLowerCase() === 'apparel' && apparelTagsTop.length"
            >
              <div class='mt-2 space-y-2 pl-6'>
                <template x-for='tag in apparelTagsTop' :key='tag.handle'>
                  <label class='flex items-center space-x-2 cursor-pointer'>
                    <input
                      type='checkbox'
                      :checked='selectedFilters.apparelTagSelected === tag.handle'
                      @change='toggleApparelTag(tag.handle, $event.target.checked)'
                      class='border-gray-300 text-black focus:ring-gray-900'
                    >
                    <span class='text-sm text-gray-700' x-text='tag.label'></span>
                  </label>
                </template>
              </div>
            </template>
          </div>
        </template>
      </div>
    </div>

    <!-- Availability Filter -->
    <div class='mb-6'>
      <button
        @click='toggleFilter("availability")'
        class='flex items-center justify-between w-full text-left font-semibold text-gray-900 mb-3'
      >
        <span>Availability</span>
        <svg
          class='w-4 h-4 transition-transform duration-200'
          :class="filtersOpen.availability ? 'rotate-180' : ''"
          fill='none'
          stroke='currentColor'
          viewBox='0 0 24 24'
        >
          <path stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'/>
        </svg>
      </button>

      <div x-show='filtersOpen.availability' class='space-y-2'>
        <!-- All option -->
        <label class='flex items-center space-x-2 cursor-pointer'>
          <input
            type='radio'
            name='availability'
            value=''
            x-model='selectedFilters.availabilitySelected'
            @change='applyFilters()'
            class='border-gray-300 text-black focus:ring-gray-900'
          >
          <span class='text-sm text-gray-700'>All</span>
        </label>
        <label class='flex items-center space-x-2 cursor-pointer'>
          <input
            type='radio'
            name='availability'
            value='in-stock'
            x-model='selectedFilters.availabilitySelected'
            @change='applyFilters()'
            class='border-gray-300 text-black focus:ring-gray-900'
          >
          <span class='text-sm text-gray-700'
            >In Stock (<span x-text='inStockCount'></span>)</span
          >
        </label>
        <label class='flex items-center space-x-2 cursor-pointer'>
          <input
            type='radio'
            name='availability'
            value='out-of-stock'
            x-model='selectedFilters.availabilitySelected'
            @change='applyFilters()'
            class='border-gray-300 text-black focus:ring-gray-900'
          >
          <span class='text-sm text-gray-700'
            >Out Of Stock (<span x-text='outOfStockCount'></span>)</span
          >
        </label>
      </div>
    </div>

    <!-- Clear Filters Button -->
    <button
      @click='clearFilters'
      class='w-full bg-gray-100 hover:bg-gray-200 text-gray-700 font-medium py-2 px-4 rounded transition-colors duration-200'
    >
      Clear Filters
    </button>
  </div>
</div>

<script>
  // Server-side filter metadata for counts
  window.__filterMeta = window.__filterMeta || {}
  window.__filterMeta.productTypes = [
    {% assign pt = collection.filters | where: 'param_name', 'filter.p.product_type' | first %}
    {% if pt and pt.values %}
      {% for v in pt.values %}
        { value: {{ v.value | json }}, count: {{ v.count | default: 0 }} }{% unless forloop.last %},{% endunless %}
      {% endfor %}
    {% endif %}
  ]
  window.__filterMeta.availability = {
    {% assign av = collection.filters | where: 'param_name', 'filter.v.availability' | first %}
    {% if av and av.values %}
      {% for v in av.values %}
        {% if v.value == '1' or v.value == true %}
          in: {{ v.count | default: 0 }},
        {% elsif v.value == '0' or v.value == false %}
          out: {{ v.count | default: 0 }},
        {% endif %}
      {% endfor %}
    {% endif %}
  }
</script>
<script type='application/json' id='kk-filter-meta'>
  {
    "productTypes": [
      {% assign pt = collection.filters | where: 'param_name', 'filter.p.product_type' | first %}
      {% if pt and pt.values %}
        {% for v in pt.values %}
          { "value": {{ v.value | json }}, "count": {{ v.count | default: 0 }} }{% unless forloop.last %},{% endunless %}
        {% endfor %}
      {% endif %}
    ]
  }
</script>
<script>
  document.addEventListener('alpine:init', () => {
    Alpine.data('collectionFilters', () => ({
      titleCase(str) {
        try {
          return String(str || '')
            .toLowerCase()
            .split(/\s+/)
            .map(w => w.charAt(0).toUpperCase() + w.slice(1))
            .join(' ')
        } catch (e) {
          return str
        }
      },
      filtersOpen: {
        productType: true,
        availability: true,
      },
      selectedFilters: {
        productType: [],
        productTypeSelected: '',
        apparelTagSelected: '',
        availabilitySelected: '',
      },
      productTypes: [],
      apparelTags: [],
      get apparelTagsTop() {
        return (this.apparelTags || []).filter(
          t => String(t.handle || '').toLowerCase().indexOf('position') === -1
        )
      },
      isInitializing: true,

      async init() {
        // Clear any cached data that might contain hidden offer
        sessionStorage.removeItem('kk_allProductTypes')

        // Build product types from products (await async fetch when needed)
        await this.buildProductTypes()

        // Hydrate selections from URL so checked states reflect current filters
        this.hydrateFromUrl()

        // Build apparel tag options from current products
        this.buildApparelTags()

        // Mark initialization complete
        this.isInitializing = false
      },

      // Fetch full product type facets from /collections/all via a lightweight JSON view
      async fetchAllProductTypesFromAllCollection() {
        try {
          const loc = new URL(window.location.href)
          const preview = loc.searchParams.get('preview_theme_id')
          const fetchUrl = preview
            ? `/collections/all?view=filter-meta&preview_theme_id=${encodeURIComponent(preview)}`
            : '/collections/all?view=filter-meta'
          const res = await fetch(fetchUrl, {
            credentials: 'same-origin',
            headers: { Accept: 'application/json' },
          })
          if (!res.ok) return []
          const text = await res.text()
          const parsed = JSON.parse(text || '{}')
          console.log(parsed)
          const arr = (parsed && parsed.productTypes) || []
          if (arr && arr.length) {
            return arr
              .map(it => ({
                value: String(it.value || ''),
                count: Number(it.count || 0),
              }))
              .filter(it => {
                const val = String(it.value || '').toLowerCase()
                return it.value && !val.includes('hidden')
              })
          }
          // Fallback: fetch list of collections and map to product types heuristically
          const url2 = preview
            ? `/collections?view=filter-meta&preview_theme_id=${encodeURIComponent(preview)}`
            : '/collections?view=filter-meta'
          const res2 = await fetch(url2, {
            credentials: 'same-origin',
            headers: { Accept: 'application/json' },
          })
          if (!res2.ok) return []
          const text2 = await res2.text()
          const parsed2 = JSON.parse(text2 || '{}')
          const colls = (parsed2 && parsed2.collections) || []
          // Convert collections to product types by title
          const HIDE_HANDLES = [
            'all',
            'frontpage',
            'products',
            'featured',
            'home',
            'home-page',
            'homepage',
            'hidden-offer',
            'featured-mobile'
          ]
          const HIDE_TITLES = [
            'featured',
            'home page',
            'products',
            'hidden offer',
            'featured mobile'
          ]
          return colls
            .filter(c => {
              const h = String(c.handle || '').toLowerCase()
              const t = String(c.title || '').toLowerCase()
              if (!h && !t) return false
              if (HIDE_HANDLES.includes(h)) return false
              if (HIDE_TITLES.includes(t)) return false
              if (t.includes('hidden') || h.includes('hidden')) return false
              return true
            })
            .map(c => ({ value: String(c.title || ''), count: 0 }))
            .filter(it => it.value)
        } catch (e) {
          return []
        }
      },

      // Get full product types from cache or fetch them once from /collections/all
      async getFullProductTypes() {
        try {
          const cached = sessionStorage.getItem('kk_allProductTypes')
          const cachedTypes = cached ? JSON.parse(cached) : null
          // If cache exists but is suspiciously small (e.g., 0 or 1), refetch to ensure full list
          if (cachedTypes && cachedTypes.length >= 2) {
            // Filter out hidden offer from cached types
            return cachedTypes.filter(t => {
              const val = String(t.value || '').toLowerCase()
              return !val.includes('hidden')
            })
          }
          const fetched = await this.fetchAllProductTypesFromAllCollection()
          if (fetched && fetched.length) {
            // Filter out hidden offer from fetched types
            const filtered = fetched.filter(t => {
              const val = String(t.value || '').toLowerCase()
              return !val.includes('hidden')
            })
            sessionStorage.setItem(
              'kk_allProductTypes',
              JSON.stringify(filtered)
            )
            return filtered
          }
          return []
        } catch (e) {
          return []
        }
      },

      hydrateFromUrl() {
        try {
          const url = new URL(window.location.href)

          // Product types (multiple allowed)
          const types = url.searchParams.getAll('filter.p.product_type')
          if (types && types.length) {
            this.selectedFilters.productType = types
            // If URL has both Knives and Custom, select Knives (since Custom is hidden)
            const hasKnives = types.some(t => t.toLowerCase() === 'knives')
            const hasCustom = types.some(t => t.toLowerCase() === 'Custom')

            if (hasKnives && hasCustom) {
              // Both present, select Knives
              this.selectedFilters.productTypeSelected = types.find(
                t => t.toLowerCase() === 'knives'
              )
            } else if (hasCustom && !hasKnives) {
              // Only Custom (from old URL or direct access), don't select anything
              this.selectedFilters.productTypeSelected = ''
            } else {
              // Normal case: use first type
              this.selectedFilters.productTypeSelected = types[0]
            }

            // Ensure the selected type is in productTypes array
            if (this.selectedFilters.productTypeSelected) {
              const selectedExists = (this.productTypes || []).some(
                pt => pt.value === this.selectedFilters.productTypeSelected
              )
              if (!selectedExists) {
                // Add it to ensure the radio button can render
                this.productTypes.push({
                  value: this.selectedFilters.productTypeSelected,
                  count: 0,
                })
              }
            }
          } else {
            // If no explicit param, infer selection from collection URL (e.g., /collections/apparels)
            const path = window.location.pathname || ''
            const m = path.match(/\/collections\/([^\/]+)/)
            const collectionHandle = m && m[1] ? decodeURIComponent(m[1]) : ''

            // Skip when viewing all collections
            if (collectionHandle && collectionHandle !== 'all') {
              const toHandle = s =>
                String(s || '')
                  .toLowerCase()
                  .trim()
                  .replace(/[^a-z0-9]+/g, '-')
                  .replace(/^-+|-+$/g, '')

              // Helper to match collection handle to product type value
              const matchesHandle = (typeValue, handle) => {
                const typeHandle = toHandle(typeValue)
                // Direct match
                if (typeHandle === handle) return true
                // Plural/singular swap
                if (
                  handle.endsWith('s') &&
                  typeHandle === handle.slice(0, 1) + handle.slice(1, -1)
                )
                  return true
                if (
                  typeHandle.endsWith('s') &&
                  handle === typeHandle.slice(0, -1)
                )
                  return true
                // Suffix match: allow collection handle being a suffix of the type handle
                // e.g., handle "knives" should match "ultralight-knives"
                if (typeHandle.endsWith('-' + handle)) return true
                return false
              }

              // Find a product type whose handle matches the collection handle
              const matchType = (this.productTypes || []).find(pt =>
                matchesHandle(pt.value, collectionHandle)
              )
              if (matchType) {
                this.selectedFilters.productTypeSelected = matchType.value

                // Auto-redirect to include custom products when on knives collection
                if (
                  matchType.value.toLowerCase() === 'knives' ||
                  collectionHandle === 'knives'
                ) {
                  // Redirect to add both Knives and custom filters
                  const newUrl = new URL(window.location.href)
                  newUrl.searchParams.append(
                    'filter.p.product_type',
                    matchType.value
                  )
                  newUrl.searchParams.append('filter.p.product_type', 'Custom')
                  if (newUrl.toString() !== window.location.href) {
                    window.location.href = newUrl.toString()
                    return
                  }
                }
              }
            }
          }

          // Availability (1=in stock, 0=out of stock)
          const avParam = url.searchParams.get('filter.v.availability')
          if (avParam !== null) {
            if (String(avParam) === '1') {
              this.selectedFilters.availabilitySelected = 'in-stock'
            } else if (String(avParam) === '0') {
              this.selectedFilters.availabilitySelected = 'out-of-stock'
            }
          }

          // Apparel tag (filter.p.tag)
          const tagParam = url.searchParams.get('filter.p.tag')
          if (tagParam) {
            this.selectedFilters.apparelTagSelected = tagParam
          }

          // Apparel tag from path /collections/all/{tag}
          const pathMatch = (url.pathname || '').match(/\/collections\/all\/([^\/]+)/)
          if (
            pathMatch &&
            pathMatch[1] &&
            this.selectedFilters.productTypeSelected.toLowerCase() === 'apparel'
          ) {
            this.selectedFilters.apparelTagSelected = decodeURIComponent(pathMatch[1])
          }
        } catch (e) {
          // ignore
        }
      },

      toggleApparelTag(tag, checked) {
        if (checked) {
          this.selectedFilters.apparelTagSelected = tag
        } else {
          this.selectedFilters.apparelTagSelected = ''
        }
        this.applyFilters()
      },

      titleCase(str) {
        try {
          return String(str || '')
            .toLowerCase()
            .split(/\s+/)
            .map(w => w.charAt(0).toUpperCase() + w.slice(1))
            .join(' ')
        } catch (e) {
          return str
        }
      },

      buildApparelTags() {
        try {
          // Only build when apparel is selected
          if (
            !this.selectedFilters.productTypeSelected ||
            this.selectedFilters.productTypeSelected.toLowerCase() !== 'apparel'
          ) {
            this.apparelTags = []
            return
          }

          const cached = sessionStorage.getItem('kk_apparelTagsAll')
          const map = {}
          if (cached) {
            try {
              const arr = JSON.parse(cached)
              arr.forEach(t => {
                if (t && t.handle) map[String(t.handle)] = t.label || t.handle
              })
            } catch (e) {
              // ignore cache parse errors
            }
          }

          const products = window.__collectionProducts || []

          products.forEach(p => {
            const typeVal = String(p.product_type || p.type || '').toLowerCase()
            if (typeVal !== 'apparel') return
            const tags = p.tags || []
            tags.forEach(tag => {
              const raw = String(tag || '').trim()
              if (!raw) return
              const low = raw.toLowerCase()
              if (low.includes('hidden')) return
              const handle = this.toHandleSafe(raw)
              if (!handle) return
              if (!map[handle]) {
                map[handle] = this.titleCase(raw)
              }
            })
          })

          const arr = Object.keys(map)
            .sort()
            .map(h => ({ handle: h, label: map[h] }))
          this.apparelTags = arr
          sessionStorage.setItem('kk_apparelTagsAll', JSON.stringify(arr))
        } catch (e) {
          this.apparelTags = []
        }
      },

      toHandleSafe(val) {
        try {
          return String(val || '')
            .toLowerCase()
            .trim()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '')
        } catch (e) {
          return ''
        }
      },

      async buildProductTypes() {
        try {
          // Prefer server-provided facet metadata when available
          const meta = window.__filterMeta || {}

          // Current page facet (may be partial). Filter out 'hidden offer'.
          const metaTypes = (meta.productTypes || [])
            .filter(t => {
              const val = String(t.value || '').toLowerCase()
              return !val.includes('hidden')
            })
            .map(t => ({
              value: String(t.value || ''),
              count: Number(t.count || 0),
            }))

          // Always attempt to use the full set from /collections/all
          const fullTypes = await this.getFullProductTypes()
          if (fullTypes && fullTypes.length) {
            this.productTypes = fullTypes
            return
          }

          // If we couldn't get a full set, fall back to meta types if present
          if (metaTypes && metaTypes.length) {
            this.productTypes = metaTypes
            return
          }

          // Last resort: derive counts from products on the current page (may be incomplete)
          const products = window.__collectionProducts || []
          const counts = {}
          products.forEach(p => {
            const t = (p.product_type || p.type || '').toString().trim()
            const tLower = t.toLowerCase()
            if (!t || tLower.includes('hidden')) return
            counts[t] = (counts[t] || 0) + 1
          })
          this.productTypes = Object.keys(counts).map(k => ({
            value: k,
            count: counts[k],
          }))
        } catch (e) {
          this.productTypes = []
        }
      },

      toggleFilter(filterName) {
        this.filtersOpen[filterName] = !this.filtersOpen[filterName]
      },

      clearFilters() {
        this.selectedFilters = {
          productType: [],
          productTypeSelected: '',
          apparelTagSelected: '',
          availabilitySelected: '',
        }
        // Clear cache to force refresh and remove any cached hidden offer data
        sessionStorage.removeItem('kk_allProductTypes')
        this.applyFilters()
      },

      get inStockCount() {
        const meta = window.__filterMeta || {}
        if (meta.availability && typeof meta.availability.in === 'number')
          return meta.availability.in
        const products = window.__collectionProducts || []
        return products ? products.filter(p => p.available).length : 0
      },

      get outOfStockCount() {
        const meta = window.__filterMeta || {}
        if (meta.availability && typeof meta.availability.out === 'number')
          return meta.availability.out
        const products = window.__collectionProducts || []
        return products ? products.filter(p => !p.available).length : 0
      },

      applyFilters(productTypeChanged = false) {
        if (this.isInitializing) return

        // Reset availability filter when product type changes
        if (productTypeChanged) {
          this.selectedFilters.availabilitySelected = ''
          this.selectedFilters.apparelTagSelected = ''
          this.apparelTags = []
        }

        // Build server-side filter URL and navigate
        const url = new URL(window.location.href)
        // Always reset pagination to the first page when filters change
        url.searchParams.delete('page')
        const currentPath = url.pathname || ''
        const m = currentPath.match(/\/collections\/([^\/]+)/)
        const currentHandle = m && m[1] ? decodeURIComponent(m[1]) : ''
        const toHandle = s =>
          String(s || '')
            .toLowerCase()
            .trim()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '')
        // product type — from single-select radio
        const selected = this.selectedFilters.productTypeSelected || ''
        url.searchParams.delete('filter.p.product_type')
        if (selected) {
          url.searchParams.append('filter.p.product_type', selected)
          // When Knives is selected, also include custom products
          if (selected.toLowerCase() === 'knives') {
            url.searchParams.append('filter.p.product_type', 'Custom')
          }
        }

        // If the selected type does not match the current collection handle,
        // navigate to /collections/all so the type filter can return results.
        if (selected) {
          const selectedHandle = toHandle(selected)
          if (
            currentHandle &&
            currentHandle !== 'all' &&
            currentHandle !== selectedHandle
          ) {
            url.pathname = '/collections/all'
          }
        } else {
          // If user chose ALL while on a specific collection, also go to /collections/all
          if (currentHandle && currentHandle !== 'all') {
            url.pathname = '/collections/all'
          }
        }

        // Apparel tag — MUST be in pathname, not query params
        if (
          selected &&
          selected.toLowerCase() === 'apparel' &&
          this.selectedFilters.apparelTagSelected
        ) {
          const tagHandle = toHandle(this.selectedFilters.apparelTagSelected)
          if (tagHandle) {
            url.pathname = `/collections/all/${tagHandle}`
          }
        } else {
          // If no apparel tag, ensure we’re not stuck on a tag URL
          if (url.pathname.match(/\/collections\/all\/[^/]+$/)) {
            url.pathname = '/collections/all'
          }
        }

        // availability
        url.searchParams.delete('filter.v.availability')
        const availabilitySelected =
          this.selectedFilters.availabilitySelected || ''
        if (availabilitySelected === 'in-stock') {
          url.searchParams.append('filter.v.availability', '1')
        } else if (availabilitySelected === 'out-of-stock') {
          url.searchParams.append('filter.v.availability', '0')
        }

        const nextUrl = url.toString()
        if (nextUrl === window.location.href) return
        window.location.href = nextUrl
      },
    }))
  })
</script>
