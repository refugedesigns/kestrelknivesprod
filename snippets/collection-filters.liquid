<!-- Collection Filters -->
<div
  class='hidden md:block w-full md:w-1/4 lg:w-1/5 mb-8 md:mb-0'
  x-data='collectionFilters()'
>
  <div class='bg-white border border-gray-200 rounded-lg p-6'>
    <h3 class='text-lg font-bold text-gray-900 mb-6'>Filters</h3>

    <!-- Product Type Filter -->
    <div class='mb-6'>
      <button
        @click='toggleFilter("productType")'
        class='flex items-center justify-between w-full text-left font-semibold text-gray-900 mb-3'
      >
        <span>PRODUCT TYPE</span>
        <svg
          class='w-4 h-4 transition-transform duration-200'
          :class="filtersOpen.productType ? 'rotate-180' : ''"
          fill='none'
          stroke='currentColor'
          viewBox='0 0 24 24'
        >
          <path stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'/>
        </svg>
      </button>

      <div x-show='filtersOpen.productType' class='space-y-2'>
        <!-- ALL option -->
        <label class='flex items-center space-x-2 cursor-pointer'>
          <input
            type='radio'
            name='productType'
            value=''
            x-model='selectedFilters.productTypeSelected'
            @change='applyFilters(true)'
            class='border-gray-300 text-black focus:ring-gray-900'
          >
          <span class='text-sm text-gray-700'>ALL</span>
        </label>

        <template x-for='t in productTypes' :key='t.value'>
          <label class='flex items-center space-x-2 cursor-pointer'>
            <input
              type='radio'
              name='productType'
              :value='t.value'
              x-model='selectedFilters.productTypeSelected'
              @change='applyFilters(true)'
              class='border-gray-300 text-black focus:ring-gray-900'
            >
            <span
              class='text-sm text-gray-700'
              x-text='t.value.toUpperCase()'
            ></span>
          </label>
        </template>
      </div>
    </div>

    <!-- Availability Filter -->
    <div class='mb-6'>
      <button
        @click='toggleFilter("availability")'
        class='flex items-center justify-between w-full text-left font-semibold text-gray-900 mb-3'
      >
        <span>AVAILABILITY</span>
        <svg
          class='w-4 h-4 transition-transform duration-200'
          :class="filtersOpen.availability ? 'rotate-180' : ''"
          fill='none'
          stroke='currentColor'
          viewBox='0 0 24 24'
        >
          <path stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'/>
        </svg>
      </button>

      <div x-show='filtersOpen.availability' class='space-y-2'>
        <label class='flex items-center space-x-2 cursor-pointer'>
          <input
            type='checkbox'
            x-model='selectedFilters.availability'
            value='in-stock'
            @change='applyFilters(true)'
            class='rounded border-gray-300 text-black focus:ring-gray-900'
          >
          <span class='text-sm text-gray-700'
            >In stock (<span x-text='inStockCount'></span>)</span
          >
        </label>
        <label class='flex items-center space-x-2 cursor-pointer'>
          <input
            type='checkbox'
            x-model='selectedFilters.availability'
            value='out-of-stock'
            @change='applyFilters(true)'
            class='rounded border-gray-300 text-black focus:ring-gray-900'
          >
          <span class='text-sm text-gray-700'
            >Out of stock (<span x-text='outOfStockCount'></span>)</span
          >
        </label>
      </div>
    </div>

    <!-- Clear Filters Button -->
    <button
      @click='clearFilters'
      class='w-full bg-gray-100 hover:bg-gray-200 text-gray-700 font-medium py-2 px-4 rounded transition-colors duration-200'
    >
      Clear Filters
    </button>
  </div>
</div>

<script>
  // Server-side filter metadata for counts
  window.__filterMeta = window.__filterMeta || {}
  window.__filterMeta.productTypes = [
    {% assign pt = collection.filters | where: 'param_name', 'filter.p.product_type' | first %}
    {% if pt and pt.values %}
      {% for v in pt.values %}
        { value: {{ v.value | json }}, count: {{ v.count | default: 0 }} }{% unless forloop.last %},{% endunless %}
      {% endfor %}
    {% endif %}
  ]
  window.__filterMeta.availability = {
    {% assign av = collection.filters | where: 'param_name', 'filter.v.availability' | first %}
    {% if av and av.values %}
      {% for v in av.values %}
        {% if v.value == '1' or v.value == true %}
          in: {{ v.count | default: 0 }},
        {% elsif v.value == '0' or v.value == false %}
          out: {{ v.count | default: 0 }},
        {% endif %}
      {% endfor %}
    {% endif %}
  }
</script>
<script>
  document.addEventListener('alpine:init', () => {
    Alpine.data('collectionFilters', () => ({
      filtersOpen: {
        productType: true,
        availability: true,
      },
      selectedFilters: {
        productType: [],
        productTypeSelected: '',
        availability: [],
      },
      productTypes: [],
      isInitializing: true,

      init() {
        // Build product types from products
        this.buildProductTypes()

        // Hydrate selections from URL so checked states reflect current filters
        this.hydrateFromUrl()

        // Mark initialization complete
        this.isInitializing = false
      },

      hydrateFromUrl() {
        try {
          const url = new URL(window.location.href)
          // Product types (multiple allowed)
          const types = url.searchParams.getAll('filter.p.product_type')
          if (types && types.length) {
            this.selectedFilters.productType = types
            this.selectedFilters.productTypeSelected = types[0]
          }

          // If no explicit param, infer selection from collection URL (e.g., /collections/apparels)
          if (!this.selectedFilters.productTypeSelected) {
            const path = window.location.pathname || ''
            const m = path.match(/\/collections\/([^\/]+)/)
            const collectionHandle = m && m[1] ? decodeURIComponent(m[1]) : ''

            // Skip when viewing all collections
            if (collectionHandle && collectionHandle !== 'all') {
              const toHandle = s =>
                String(s || '')
                  .toLowerCase()
                  .trim()
                  .replace(/[^a-z0-9]+/g, '-')
                  .replace(/^-+|-+$/g, '')

              // Find a product type whose handle matches the collection handle
              const matchType = (this.productTypes || []).find(
                pt => toHandle(pt.value) === collectionHandle
              )
              if (matchType) {
                this.selectedFilters.productTypeSelected = matchType.value
              }
            }
          }

          // Availability (1=in stock, 0=out of stock). Could appear multiple times
          const avParams = url.searchParams.getAll('filter.v.availability')
          const av = []
          avParams.forEach(v => {
            if (String(v) === '1') av.push('in-stock')
            if (String(v) === '0') av.push('out-of-stock')
          })
          if (av.length) this.selectedFilters.availability = av
        } catch (e) {
          // ignore
        }
      },

      buildProductTypes() {
        try {
          // Prefer server-provided facet metadata when available
          const meta = window.__filterMeta || {}

          // Try to use a previously cached full list (from an unfiltered visit)
          const cached = sessionStorage.getItem('kk_allProductTypes')
          const cachedTypes = cached ? JSON.parse(cached) : null

          if (meta.productTypes && meta.productTypes.length > 1) {
            // When more than one option is present, assume it's a full facet and cache it
            this.productTypes = meta.productTypes
            sessionStorage.setItem(
              'kk_allProductTypes',
              JSON.stringify(this.productTypes)
            )
            return
          }

          if (
            meta.productTypes &&
            meta.productTypes.length === 1 &&
            cachedTypes &&
            cachedTypes.length > 0
          ) {
            // If facet collapsed to a single selected type, fallback to cached full list
            this.productTypes = cachedTypes
            return
          }

          // Fallback: derive counts from products on the current page (may be incomplete)
          const products = window.__collectionProducts || []
          const counts = {}
          products.forEach(p => {
            const t = (p.product_type || p.type || '').toString().trim()
            if (!t) return
            counts[t] = (counts[t] || 0) + 1
          })
          this.productTypes = Object.keys(counts).map(k => ({
            value: k,
            count: counts[k],
          }))
        } catch (e) {
          this.productTypes = []
        }
      },

      toggleFilter(filterName) {
        this.filtersOpen[filterName] = !this.filtersOpen[filterName]
      },

      clearFilters() {
        this.selectedFilters = {
          productType: [],
          productTypeSelected: '',
          availability: [],
        }
        sessionStorage.removeItem('kk_allProductTypes')
        this.applyFilters()
      },

      get inStockCount() {
        const meta = window.__filterMeta || {}
        if (meta.availability && typeof meta.availability.in === 'number')
          return meta.availability.in
        const products = window.__collectionProducts || []
        return products ? products.filter(p => p.available).length : 0
      },

      get outOfStockCount() {
        const meta = window.__filterMeta || {}
        if (meta.availability && typeof meta.availability.out === 'number')
          return meta.availability.out
        const products = window.__collectionProducts || []
        return products ? products.filter(p => !p.available).length : 0
      },

      applyFilters() {
        if (this.isInitializing) return
        // Build server-side filter URL and navigate
        const url = new URL(window.location.href)
        // Always reset pagination to the first page when filters change
        url.searchParams.delete('page')
        const currentPath = url.pathname || ''
        const m = currentPath.match(/\/collections\/([^\/]+)/)
        const currentHandle = m && m[1] ? decodeURIComponent(m[1]) : ''
        const toHandle = s =>
          String(s || '')
            .toLowerCase()
            .trim()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '')
        // product type â€” from single-select radio
        const selected = this.selectedFilters.productTypeSelected || ''
        url.searchParams.delete('filter.p.product_type')
        if (selected) {
          url.searchParams.append('filter.p.product_type', selected)
        }

        // If the selected type does not match the current collection handle,
        // navigate to /collections/all so the type filter can return results.
        if (selected) {
          const selectedHandle = toHandle(selected)
          if (
            currentHandle &&
            currentHandle !== 'all' &&
            currentHandle !== selectedHandle
          ) {
            url.pathname = '/collections/all'
          }
        } else {
          // If user chose ALL while on a specific collection, also go to /collections/all
          if (currentHandle && currentHandle !== 'all') {
            url.pathname = '/collections/all'
          }
        }
        // availability
        url.searchParams.delete('filter.v.availability')
        const hasIn = (this.selectedFilters.availability || []).includes(
          'in-stock'
        )
        const hasOut = (this.selectedFilters.availability || []).includes(
          'out-of-stock'
        )
        if (hasIn && !hasOut)
          url.searchParams.append('filter.v.availability', '1')
        if (hasOut && !hasIn)
          url.searchParams.append('filter.v.availability', '0')

        const nextUrl = url.toString()
        if (nextUrl === window.location.href) return
        window.location.href = nextUrl
      },
    }))
  })
</script>
